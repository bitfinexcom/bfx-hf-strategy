<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>lib/helpers/index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-Architectural Overview.html">Architectural Overview</a></li><li class="nav-item"><a href="tutorial-Backtesting Offline.html">Backtesting Offline</a></li><li class="nav-item"><a href="tutorial-Backtesting Online.html">Backtesting Online</a></li><li class="nav-item"><a href="tutorial-Live Execution.html">Live Execution</a></li><li class="nav-item"><a href="tutorial-Order Creation.html">Order Creation</a></li><li class="nav-item"><a href="tutorial-Plugin System.html">Plugin System</a></li><li class="nav-item"><a href="tutorial-Strategy Design.html">Strategy Design</a></li><li class="nav-item"><a href="tutorial-Using Indicators.html">Using Indicators</a></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-Helpers.html">Helpers</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.closeOpenPositions">closeOpenPositions</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.closePosition">closePosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.closePositionLimit">closePositionLimit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.closePositionMarket">closePositionMarket</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.closePositionWithOrder">closePositionWithOrder</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.condition">condition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.conditionInAPosition">conditionInAPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.conditionIndicatorCrossed">conditionIndicatorCrossed</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.conditionIndicatorsCrossed">conditionIndicatorsCrossed</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.enforceMinTradeInterval">enforceMinTradeInterval</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.getLastPrice">getLastPrice</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.getState">getState</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.inALongPosition">inALongPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.inAPosition">inAPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.inAShortPosition">inAShortPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.indicators">indicators</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.indicatorValues">indicatorValues</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.minTradeIntervalMet">minTradeIntervalMet</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.openLongPosition">openLongPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.openLongPositionLimit">openLongPositionLimit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.openLongPositionMarket">openLongPositionMarket</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.openPosition">openPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.openPositionLimit">openPositionLimit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.openPositionMarket">openPositionMarket</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.openPositionWithOrder">openPositionWithOrder</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.openShortPosition">openShortPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.openShortPositionLimit">openShortPositionLimit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.openShortPositionMarket">openShortPositionMarket</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.trades">trades</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.updateLongPosition">updateLongPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.updateLongPositionLimit">updateLongPositionLimit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.updateLongPositionLimit">updateLongPositionLimit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.updateLongPositionMarket">updateLongPositionMarket</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.updatePosition">updatePosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.updatePositionMarket">updatePositionMarket</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.updatePositionWithOrder">updatePositionWithOrder</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.updateShortPosition">updateShortPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.updateShortPositionLimit">updateShortPositionLimit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.updateShortPositionLimit">updateShortPositionLimit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.withNoPosition">withNoPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Helpers.html#.withPosition">withPosition</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#defineStrategy">defineStrategy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#execOffline">execOffline</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#execOnline">execOnline</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">lib/helpers/index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

const debug = require('debug')
const { TIME_FRAME_WIDTHS } = require('bfx-hf-util')
const _isString = require('lodash/isString')
const _isObject = require('lodash/isObject')
const _isFinite = require('lodash/isFinite')
const _includes = require('lodash/includes')
const _some = require('lodash/some')
const _last = require('lodash/last')

const { breakExec, evaluateCondition } = require('../util')
const { safeThrow, ErrorInterruptExec } = require('../errors')
const { indicatorValues } = require('../indicators')
const {
  closeOpenPositions, closePosition, closePositionLimit, closePositionMarket,
  closePositionWithOrder, openLongPosition, openLongPositionLimit,
  openLongPositionMarket, openPosition, openPositionLimit, openPositionMarket,
  openPositionWithOrder, openShortPosition, openShortPositionLimit,
  openShortPositionMarket, updateLongPosition, updateLongPositionLimit,
  updateLongPositionMarket, updatePosition, updatePositionLimit,
  updatePositionMarket, updatePositionWithOrder, updateShortPosition,
  updateShortPositionLimit, updateShortPositionMarket, withNoPosition,
  withPosition
} = require('../position')
const {
  getDefaultSymbol, getPosition, getIndicator, getLastPrice, getStrategyTrades,
  getIndicators, getCandles, getFees, getDefaultTF
} = require('../data')

/**
 * A set of utility functions bound to the strategy they are used in, providing
 * control over strategy execution, access to data, and order manipulation
 * methods.
 *
 * @module Helpers
 */

const initHelpersForStrategy = (strategy = {}) => {
  const h = {}
  const _d = debug('live >')
  const liveDebug = (...args) => {
    if (!strategy.backtesting) {
      _d(...args)
    }
  }

  // We can safely log start here as helpers are initialized prior to execution
  liveDebug('starting up at %s', new Date().toLocaleString())

  // TODO: doc
  h.isBacktesting = () => !!strategy.backtesting

  // TODO: doc
  h.liveLog = (...args) => liveDebug(...args)

  // TODO: doc
  h.fees = () => getFees(strategy)

  // TODO: doc
  h.nCandles = (symbol, tf) => (
    getCandles(strategy, symbol, tf).length
  )

  // TODO: doc
  h.candles = (symbol, tf) => (
    getCandles(strategy, symbol, tf)
  )

  h.currentCandle = (symbol, tf) => (
    _last(getCandles(strategy, symbol, tf))
  )

  // TODO: doc
  h.prevCandles = (n = 1, offset = 0, symbol, tf) => {
    const candles = getCandles(strategy, symbol, tf)
    return candles.slice(candles.length - 1 - n - offset, candles.length - 1 - offset)
  }

  // TODO: doc
  h.indicatorWasNotRecently = (id, condition, lookback = 30) => {
    const window = h.prevCandles(lookback).map(c => c.iv[id])
    return !_some(window, condition)
  }

  /**
   * Returns the strategy's trades
   *
   * @memberof module:Helpers
   * @alias module:Helpers.trades
   *
   * @returns {StrategyTrade[]} trades
   */
  h.trades = () => getStrategyTrades(strategy)

  /**
   * Closes all open positions with market orders
   *
   * @memberof module:Helpers
   * @alias module:Helpers.closeOpenPositions
   *
   * @returns {Promise} p
   */
  h.closeOpenPositions = () => closeOpenPositions(strategy)

  /**
   * Closes an open position with an order. Throws an error if no position is open
   * for the order's symbol.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.closePosition
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.closePosition = (params) => closePosition(strategy, params)

  /**
   * Closes a position with a limit order
   *
   * @memberof module:Helpers
   * @alias module:Helpers.closePositionLimit
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.closePositionLimit = (params) => closePositionLimit(strategy, params)

  /**
   * Closes a position with a market order
   *
   * @memberof module:Helpers
   * @alias module:Helpers.closePositionMarket
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.closePositionMarket = (params) => closePositionMarket(strategy, params)

  /**
   * Closes an open position with an order. Throws an error if no position is open
   * for the order's symbol.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.closePositionWithOrder
   * @throws {Error} Fails if no position is open for the symbol, if the provided
   *   order would not close the position, or if given invalid order parameters
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.closePositionWithOrder = (params) => closePositionWithOrder(strategy, params)

  /**
   * Alias for openPositon
   *
   * @memberof module:Helpers
   * @alias module:Helpers.openLongPosition
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.openLongPosition = (params) => openLongPosition(strategy, params)

  /**
   * Opens a new long position with a limit order
   *
   * @memberof module:Helpers
   * @alias module:Helpers.openLongPositionLimit
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.openLongPositionLimit = (params) => openLongPositionLimit(strategy, params)

  /**
   * Opens a new long position with a market order
   *
   * @memberof module:Helpers
   * @alias module:Helpers.openLongPositionMarket
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.openLongPositionMarket = (params) => openLongPositionMarket(strategy, params)

  /**
   * Opens a position with a new order; resolves to an error if a position is
   * already open.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.openPosition
   *
   * @param {OrderParameters} params - passed directly to order constructor
   * @returns {Promise} p
   * @throws {Error} Fails if a position already exists for the specified symbol
   */
  h.openPosition = (params) => openPosition(strategy, params)

  /**
   * Opens a new position with a limit order
   *
   * @memberof module:Helpers
   * @alias module:Helpers.openPositionLimit
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   * @throws {Error} Fails if a position already exists for the specified symbol
   */
  h.openPositionLimit = (params) => openPositionLimit(strategy, params)

  /**
   * Opens a new position with a market order. Pulls order timestamp and price
   * from last received data for the order's symbol.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.openPositionMarket
   * @throws {Error} If no timestamp or price data available and none supplied
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.openPositionMarket = (params) => openPositionMarket(strategy, params)

  /**
   * Submits a new order via ws2 with the supplied parameters, creates a new
   * strategy trade and creates a position.
   *
   * If no ws client is available, no data is saved &amp; no order is dispatched
   *
   * @memberof module:Helpers
   * @alias module:Helpers.openPositionWithOrder
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   * @throws {Error} Fails if a position already exists for the specified symbol
   */
  h.openPositionWithOrder = (params) => openPositionWithOrder(strategy, params)

  /**
   * Opens a short position (negates passed amount)
   *
   * @memberof module:Helpers
   * @alias module:Helpers.openShortPosition
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   * @throws {Error} Fails if a position already exists for the specified symbol
   */
  h.openShortPosition = (params) => openShortPosition(strategy, params)

  /**
   * Opens a short position (negates passed amount)
   *
   * @memberof module:Helpers
   * @alias module:Helpers.openShortPositionLimit
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   * @throws {Error} Fails if a position already exists for the specified symbol
   */
  h.openShortPositionLimit = (params) => openShortPositionLimit(strategy, params)

  /**
   * Opens a short position (negates passed amount)
   *
   * @memberof module:Helpers
   * @alias module:Helpers.openShortPositionMarket
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   * @throws {Error} Fails if a position already exists for the specified symbol
   */
  h.openShortPositionMarket = (params) => openShortPositionMarket(strategy, params)

  /**
   *
   * @memberof module:Helpers
   * @alias module:Helpers.updateLongPosition
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.updateLongPosition = (params) => updateLongPosition(strategy, params)

  /**
   * Updates a long position with a limit order
   *
   * @memberof module:Helpers
   * @alias module:Helpers.updateLongPositionLimit
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.updateLongPositionLimit = (params) => updateLongPositionLimit(strategy, params)

  /**
   * Updates a long position with a market order
   *
   * @memberof module:Helpers
   * @alias module:Helpers.updateLongPositionMarket
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.updateLongPositionMarket = (params) => updateLongPositionMarket(strategy, params)

  /**
   * Alias for updatePositionWithOrder
   *
   * @memberof module:Helpers
   * @alias module:Helpers.updatePosition
   *
   * @param {OrderParameters} params - passed directly to order constructor
   * @returns {Promise} p
   */
  h.updatePosition = (params) => updatePosition(strategy, params)

  /**
   * Updates a position with a limit order
   *
   * @memberof module:Helpers
   * @alias module:Helpers.updateLongPositionLimit
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.updatePositionLimit = (params) => updatePositionLimit(strategy, params)

  /**
   * Updates a new position with a market order. Pulls order timestamp and price
   * from last received data for the order's symbol.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.updatePositionMarket
   * @throws {Error} If no timestamp or price data available and none supplied
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.updatePositionMarket = (params) => updatePositionMarket(strategy, params)

  /**
   * Submits a new order via ws2 with the supplied parameters, creates a new
   * strategy trade and updates the current position.
   *
   * If no ws client is available, no data is saved &amp; no order is dispatched
   *
   * @memberof module:Helpers
   * @alias module:Helpers.updatePositionWithOrder
   * @throws {Error} Fails if no position is open for the symbol, if the order
   *   would close the position, or if given invalid order parameters
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.updatePositionWithOrder = (params) => updatePositionWithOrder(strategy, params)

  /**
   * Updates a short position (negates passed amount)
   *
   * @memberof module:Helpers
   * @alias module:Helpers.updateShortPosition
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.updateShortPosition = (params) => updateShortPosition(strategy, params)

  /**
   * Updates a short position (negates passed amount)
   *
   * @memberof module:Helpers
   * @alias module:Helpers.updateShortPositionLimit
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.updateShortPositionLimit = (params) => updateShortPositionLimit(strategy, params)

  /**
   * Updates a short position (negates passed amount)
   *
   * @memberof module:Helpers
   * @alias module:Helpers.updateShortPositionLimit
   *
   * @param {OrderParameters} params - order parameters
   * @returns {Promise} p
   */
  h.updateShortPositionMarket = (params) => updateShortPositionMarket(strategy, params)

  /**
   * Calls the provided async function if no position is open for the symbol
   *
   * @memberof module:Helpers
   * @alias module:Helpers.withNoPosition
   *
   * @param {string} [symbol] - symbol
   * @param {Function} f - async function to call if no position is open
   * @returns {Promise} p
   */
  h.withNoPosition = (symbol, f) => withNoPosition(strategy, symbol, f)

  /**
   * Calls the provided async function with the position if it is open
   *
   * @memberof module:Helpers
   * @alias module:Helpers.withPosition
   *
   * @param {string} [symbol] - symbol
   * @param {Function} f - async function to call if position is open
   * @returns {Promise} p
   */
  h.withPosition = (symbol, f) => withPosition(strategy, symbol, f)

  /**
   * Evaluates whether the time since the last strategy trade is greater than
   * the specified interval in milliseconds.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.minTradeIntervalMet
   *
   * @param {number} intervalMS - interval in milliseconds
   * @returns {boolean} intervalMet
   */
  h.minTradeIntervalMet = (intervalMS) => {
    const lastTrade = _last(getStrategyTrades(strategy))

    return lastTrade
      ? Date.now() - lastTrade.mts > intervalMS
      : true
  }

  // TODO: doc
  h.lastTrade = (n = 0) => {
    const trades = getStrategyTrades(strategy)
    return trades[trades.length - 1 - n]
  }

  // TODO: doc
  h.ticksSinceLastTrade = (_tf) => {
    const tf = _tf || getDefaultTF(strategy)
    const symbol = getDefaultSymbol(strategy)
    const trade = h.lastTrade()
    const { mts } = h.getLastPrice(symbol, tf)

    return !trade
      ? -1
      : (mts - trade.mts) / TIME_FRAME_WIDTHS[tf]
  }

  /**
   * Breaks execution if the time since the last strategy trade is less than
   * the specified interval in milliseconds.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.enforceMinTradeInterval
   *
   * @param {number} intervalMS - interval in milliseconds
   */
  h.enforceMinTradeInterval = (intervalMS) => {
    if (!h.minTradeIntervalMet(intervalMS)) {
      breakExec(`min trade interval not met: ${intervalMS}ms`)
    }
  }

  /**
   * Returns the strategy state
   *
   * @memberof module:Helpers
   * @alias module:Helpers.getState
   *
   * @returns {object} state
   */
  h.getState = () => strategy

  /**
   * Returns the last received price (from a trade or candle) for the specified
   * symbol/timeframe pair.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.getLastPrice
   *
   * @param {string} symbol - defaults to default strategy symbol
   * @param {string} tf - defaults to default strategy timeframe
   * @returns {number} lastPrice
   */
  h.getLastPrice = (symbol, tf) => getLastPrice(strategy, symbol, tf)

  /**
   * Returns a map of indicator values key'ed by indicator ID
   *
   * @memberof module:Helpers
   * @alias module:Helpers.indicatorValues
   *
   * @returns {object} values
   */
  h.indicatorValues = () => indicatorValues(strategy)

  /**
   * Returns a map of indicators key'ed by ID
   *
   * @memberof module:Helpers
   * @alias module:Helpers.indicators
   *
   * @returns {object} indicators
   */
  h.indicators = () => getIndicators(strategy)

  /**
   * Returns true if a position is open for the specified symbol
   *
   * @memberof module:Helpers
   * @alias module:Helpers.inAPosition
   *
   * @param {string} symbol - defaults to default strategy symbol
   * @returns {boolean} inPosition
   */
  h.inAPosition = (symbol = getDefaultSymbol(strategy)) => {
    return !!getPosition(strategy, symbol)
  }

  /**
   * Returns true if a long position is open for the specified symbol.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.inALongPosition
   *
   * @param {string} symbol - defaults to default strategy symbol
   * @returns {boolean} inLongPosition
   */
  h.inALongPosition = (symbol = getDefaultSymbol(strategy)) => {
    const position = getPosition(strategy, symbol)
    return position &amp;&amp; position.amount > 0
  }

  /**
   * Returns true if a short position is open for the specified symbol.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.inAShortPosition
   *
   * @param {string} symbol - defaults to default strategy symbol
   * @returns {boolean} inShortPosition
   */
  h.inAShortPosition = (symbol = getDefaultSymbol(strategy)) => {
    const position = getPosition(strategy, symbol)
    return position &amp;&amp; position.amount &lt; 0
  }

  /**
   * Returns a strategy indicator by ID.
   *
   * @memberof module:Helpers
   * @private
   * @throws {Error} Fails if given an unknown indicator ID. Logs an error if
   *   executing live.
   *
   * @param {string} id - indicator ID
   * @returns {Indicator} indicator
   */
  const indicatorParam = (id) => {
    const i = getIndicator(strategy, id)

    if (!_isObject(i)) {
      safeThrow(strategy, `Unknown indicator ID: ${id}`)
      return null
    }

    return i
  }

  /**
   * Converts an indicator ID or ID.key string into a literal value. Returns
   * the value as-is if it is finite.
   *
   * @memberof module:Helpers
   * @private
   * @throws {Error} Fails if not given a string or number
   *
   * @param {string|number} v - indicator ID or literal value
   * @returns {number} value
   */
  const indicatorOrLiteralParamToLiteral = (v) => {
    if (_isFinite(v)) {
      return v
    } else if (_isString(v)) {
      if (_includes(v, '.')) {
        const [iID, vKey] = v.split('.')
        return indicatorParam(iID).v()[vKey]
      } else {
        return indicatorParam(v).v()
      }
    } else {
      throw new Error(`Unknown param ${v}, not number or indicator ID string`)
    }
  }

  /**
   * Interrupts execution if the condition is not meant. Either parameter to
   * the condition can be an indicator ID or literal. If given an indicator
   * ID and the indicator has sub-values (i.e. bollinger bands), the sub-value
   * name can be specified following a dot after the indicator name
   * (i.e. 'bb.middle')
   *
   * @memberof module:Helpers
   * @alias module:Helpers.condition
   *
   * @param {string|number} a - indicator ID or literal
   * @param {string} condition - one of (=, ==, eq), (!=, !==, neq), (>, gt),
   *   (>=, gte), (&lt;, lt), or (&lt;=, lte)
   * @param {string|number} b - indicator ID or literal
   * @throws {Error} Fails if given an unknown indicator ID. Logs an error if
   *   executing live.
   */
  h.condition = (a, condition, b) => {
    const aV = indicatorOrLiteralParamToLiteral(a)
    const bV = indicatorOrLiteralParamToLiteral(b)

    if (aV === null || bV === null) {
      breakExec('invalid parameters')
    } else if (!evaluateCondition(strategy, aV, condition, bV)) {
      breakExec(`condition not met: ${aV} (${a}) ${condition} ${bV} (${b})`)
    }
  }

  /**
   * Interrupts execution if the specified indicator did not cross the provided
   * literal value. Always breaks execution when given an unknown indicator ID
   * and running live.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.conditionIndicatorCrossed
   *
   * @param {string} iID - ID of indicator
   * @param {number} v - literal value
   * @throws {Error} Fails if an unknown indicator was specified and
   *   backtesting. Logs an error if executing live.
   */
  h.conditionIndicatorCrossed = (iID, v) => {
    const i = indicatorParam(iID)

    if (i === null) {
      breakExec('Invalid parameters')
    } else if (!i.crossed(v)) {
      breakExec(`condition fail: indicator ${iID} did not cross ${v}`)
    }
  }

  /**
   * Interrupts execution if the specified indicators did not cross values.
   * Always breaks execution when given an uknown indicator ID and running live.
   *
   * @memberof module:Helpers
   * @alias module:Helpers.conditionIndicatorsCrossed
   *
   * @param {string} iaID - ID of first indicator
   * @param {string} ibID - ID of second indicator
   * @throws {Error} Fails if either indicator ID is unknown and backtesting.
   *   Logs an error if executing live.
   */
  h.conditionIndicatorsCrossed = (iaID, ibID) => {
    const iB = indicatorParam(ibID)

    if (iB === null) {
      breakExec('invalid parameters')
    } else {
      h.condition.indicatorCrossed(iaID, iB.v())
    }
  }

  /**
   * Interrupts strategy execution if not in a position for the specified
   * symbol
   *
   * @memberof module:Helpers
   * @alias module:Helpers.conditionInAPosition
   *
   * @param {string} symbol - defaults to default strategy symbol
   */
  h.conditionInAPosition = (symbol = getDefaultSymbol(strategy)) => {
    if (!h.inAPosition(symbol)) {
      throw new ErrorInterruptExec('condition fail: not in a position')
    }
  }

  return h
}

module.exports = initHelpersForStrategy
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Wed May 06 2020 01:53:37 GMT+0700 (Indochina Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
